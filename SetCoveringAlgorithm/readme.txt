## 📌 Set Covering Algorithm

---

### 💠문제 설명

전체집합 U와 이걸 커버하는 10개의 부분집합 F = {S1 ~ S10}이 있음  
목표는 2가지:

-   **문제1**: 가장 적은 수의 부분집합으로 전체를 커버하기 (비용 고려안함)
-   **문제2**: 각 부분집합마다 비용(Cost)이 있을 때, 전체 비용이 가장 작도록 커버하기

🧠 힌트: 문제2는 '가성비(커버하는 원소 수 / 비용)'를 따져야 함

---

### 💠입력 (U, F, Cost)

U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

S1 = {1, 2, 3, 8} => Cost 6

S2 = {1, 2, 3, 4, 8} => Cost 10

S3 = {1, 2, 3, 4} => Cost 4

S4 = {2, 3, 4, 5, 7, 8} => Cost 12

S5 = {4, 5, 6, 7} => Cost 4

S6 = {5, 6, 7, 9, 10} => Cost 8

S7 = {4, 5, 6, 7} => Cost 4

S8 = {1, 2, 4, 8} => Cost 4

S9 = {6, 9} => Cost 3

S10 = {6, 10} => Cost 4

---

### 💠핵심 아이디어

**문제1: 기본 Greedy 알고리즘**

-   매 단계에서 아직 안 커버된 원소를 가장 많이 포함하는 부분집합을 고름

**문제2: 비용 최적화 Greedy 알고리즘**

-   가성비 = (이번에 커버할 수 있는 원소 수) / (그 집합의 비용)
-   가성비가 제일 높은 부분집합을 매번 선택

✍️ 결국 "욕심쟁이 알고리즘(Greedy)"을 잘 다듬어 쓴 버전

---

### 💠구현 설명

-   주요 구조체: Subsets → 원소들 + 크기 + 비용 포함
-   상태 관리: flag\[\] 배열로 어떤 원소가 커버됐는지 관리함
-   함수 설명:

```
selectSet() // 커버해야 할 원소가 많은 / 가성비 높은 집합 선택 
subtractSet() // 선택된 집합의 원소를 flag로 체크 
setCover() // 전체 루프 돌면서 covering 수행
```

📌 참고: 문제1과 문제2는 selectSet() 함수만 다름

### 💠고찰

#### 문제1

-   그냥 "가장 많이 커버하는 집합"을 고르다보니, 중복되거나 비효율적인 선택 가능
-   첫 선택이 전체 흐름에 큰 영향을 줌  
    👉 Greedy의 한계

#### 문제2

-   가성비 개념을 넣어서 효율적으로 커버하도록 설계
-   전체적인 비용은 확실히 줄어듬  
    👉 하지만 이것도 항상 최적은 아님 (Greedy 특성상)

####  전체적으로...

-   예외 처리도 있음 (커버 안되는 경우 메시지 출력)
-   입력이 바뀌어도 코드는 유연하게 작동하도록 작성함

---

### 💠추신

-   전체집합, 부분집합은 main()에서 배열로 선언했지만, 구조적으로 전역변수 + 함수로 분리했으면 더 깔끔했을 듯
-   리팩토링 여지가 남아있음 (ex. 함수 분리, 추상화)
